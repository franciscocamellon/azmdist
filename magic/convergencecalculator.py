# -*- coding: utf-8 -*-
"""
/***************************************************************************
 azmDist
                                 A QGIS plugin
 This plugin calculates the azimuth and distance between two points or a sequence of points.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2019-08-18
        git sha              : $Format:%H$
        copyright            : (C) 2019 by Francisco A Camello N
        email                : franciscocamellon@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.core import QgsFeature, QgsProject, QgsGeometry, QgsPointXY, QgsCoordinateReferenceSystem, QgsDistanceArea, QgsCoordinateTransform
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import *
from qgis.PyQt.QtWidgets import QAction, QFileDialog

import math


class Calculus:

	def __init__(self, iface):
		self.iface = iface

	def dd2dms(self, azm):
		is_positive = azm >= 0
		azm = abs(azm)
		minutes, seconds = divmod(azm * 3600, 60)
		degrees, minutes = divmod(minutes, 60)
		degrees = str(int(degrees)) if is_positive else '-' + str(int(degrees))
		minutes = int(minutes)

		return degrees + u"\u00b0" + str(minutes).zfill(2) + "'" + "%0.2f" % (seconds) + "''"

	def getGeographicCoordinates(self, layer, x, y):
		"""Transform the planar coordinates to geographic coordinates
		"""
		# setar o currentLayer com o layer escolhido no dialog
		self.iface.setActiveLayer(layer)
		crsSrc = self.iface.mapCanvas().currentLayer().crs()
		crsDest = QgsCoordinateReferenceSystem(crsSrc.geographicCrsAuthId())
		coordinateTransformer = QgsCoordinateTransform(crsSrc, crsDest, QgsProject.instance())
		geoPoint = coordinateTransformer.transform(QgsPointXY(x, y))

		return geoPoint

	def getSemiMajorAndSemiMinorAxis(self, layer):
		"""Obtains the semi major axis and semi minor axis from the used ellipsoid
		"""
		self.iface.setActiveLayer(layer)
		currentLayer = self.iface.mapCanvas().currentLayer()  # mudar para o layer escolhido no dialog
		distanceArea = QgsDistanceArea()
		distanceArea.setEllipsoid(currentLayer.crs().ellipsoidAcronym())
		a = distanceArea.ellipsoidSemiMajor()
		b = distanceArea.ellipsoidSemiMinor()

		return a, b

	def calculateConvergence(self, longitude, latitude, a, b):
		"""Calculates the meridian magic
		"""
		centralMeridian = int(abs(longitude) / 6) * 6 + 3
		if longitude < 0:
			centralMeridian = centralMeridian * (-1)

		deltaLong = abs(centralMeridian - longitude)

		p = 0.0001 * (deltaLong * 3600)

		xii = math.sin(math.radians(latitude)) * math.pow(10, 4)

		e2 = math.sqrt(a * a - b * b) / b

		c5 = math.pow(math.sin(math.radians(1 / 3600)), 4) * math.sin(math.radians(latitude)) * math.pow(	math.cos(math.radians(latitude)), 4) * (2 - math.pow(math.tan(math.radians(latitude)), 2)) * math.pow(10,	20) / 15

		xiii = math.pow(math.sin(math.radians(1 / 3600)), 2) * math.sin(math.radians(latitude)) * math.pow(math.cos(math.radians(latitude)), 2) * (1 + 3 * e2 * e2 * math.pow(math.cos(math.radians(latitude)), 2) + 2 * math.pow(e2, 4) * math.pow(math.cos(math.radians(latitude)), 4)) * math.pow(10, 12) / 3

		cSeconds = xii * p + xiii * math.pow(p, 3) + c5 * math.pow(p, 5)

		c = cSeconds / 3600

		return c

	def theMaker(self, aDict, alayer):
		feats = []
		for i in range(0, len(aDict) - 1):
			frwrd = QgsPointXY(aDict[i][1])  # start point
			rvrs = QgsPointXY(aDict[i + 1][1])  # second point
			az = frwrd.azimuth(rvrs)
			distance = math.sqrt(frwrd.sqrDist(rvrs))
			c = Calculus.getSemiMajorAndSemiMinorAxis(self, alayer)
			a = Calculus.getGeographicCoordinates(self, alayer, rvrs.x(), rvrs.y())
			conv = Calculus.calculateConvergence(self, a.x(), a.y(), c[0], c[1])
			if az < 0:
				az += 360
			azm = az + conv
			longitude = Calculus.dd2dms(self, Calculus.getGeographicCoordinates(self, alayer,
				aDict[i][1].x(), aDict[i][1].y()).x())
			latitude = Calculus.dd2dms(self, Calculus.getGeographicCoordinates(self, alayer,
				aDict[i][1].x(), aDict[i][1].y()).y())
			fet = QgsFeature()
			geom = QgsGeometry().fromPointXY(aDict[0][1])
			fet.setGeometry(geom)
			feats.append(fet)
			fet.setAttributes([list(aDict.keys())[i], aDict[i][0], aDict[i][1].x(), aDict[i][1].y(),
				longitude, latitude, aDict[i + 1][0], Calculus.dd2dms(self, azm), distance])

		return feats